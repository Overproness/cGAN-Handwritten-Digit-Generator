import streamlit as st
import torch
import torch.nn as nn
import numpy as np
import torchvision.utils as vutils

# --- 1. Model Architecture (Must be identical to the training script) ---

# Parameters (should match the training script)
LATENT_DIM = 100
N_CLASSES = 10
IMG_SHAPE = (1, 28, 28)
EMBEDDING_DIM = 50

# Define the Generator class again
class Generator(nn.Module):
    def __init__(self):
        super(Generator, self).__init__()
        self.label_embedding = nn.Embedding(N_CLASSES, EMBEDDING_DIM)
        self.model = nn.Sequential(
            nn.Linear(LATENT_DIM + EMBEDDING_DIM, 256),
            nn.LeakyReLU(0.2, inplace=True),
            nn.Linear(256, 512),
            nn.LeakyReLU(0.2, inplace=True),
            nn.Linear(512, 1024),
            nn.LeakyReLU(0.2, inplace=True),
            nn.Linear(1024, int(np.prod(IMG_SHAPE))),
            nn.Tanh()
        )

    def forward(self, noise, labels):
        label_embedding = self.label_embedding(labels)
        gen_input = torch.cat((label_embedding, noise), -1)
        img = self.model(gen_input)
        img = img.view(img.size(0), *IMG_SHAPE)
        return img

# --- 2. Load the Trained Model ---

# Use a cache to load the model only once
@st.cache_resource
def load_model():
    model = Generator()
    # Load the weights from the file. Use map_location for CPU execution.
    model.load_state_dict(torch.load('cgan_generator.pth', map_location=torch.device('cpu')))
    model.eval() # Set the model to evaluation mode
    return model

generator = load_model()
device = torch.device("cpu") # App will run on CPU

# --- 3. Web Application UI ---

st.set_page_config(layout="wide")
st.title("Handwritten Digit Generation using a cGAN")

st.write("""
This web app generates images of handwritten digits (0-9). The images are generated by a Conditional Generative Adversarial Network (cGAN) trained on the MNIST dataset. Select a digit from the dropdown below and click 'Generate' to see five unique examples.
""")

st.divider()

# --- 4. User Input and Image Generation ---
col1, col2 = st.columns([1, 3])

with col1:
    # User selects which digit to generate
    selected_digit = st.selectbox("Select a digit to generate:", list(range(10)))
    
    # Generate button
    generate_button = st.button("Generate Images", type="primary")

with col2:
    if generate_button:
        # Generate 5 images
        num_images = 5
        
        # Prepare noise and labels
        with torch.no_grad(): # No need to track gradients
            noise = torch.randn(num_images, LATENT_DIM, device=device)
            labels = torch.full((num_images,), selected_digit, dtype=torch.long, device=device)
            
            # Generate images
            generated_images = generator(noise, labels)
            
            # Un-normalize the images from [-1, 1] to [0, 1] for display
            generated_images = generated_images * 0.5 + 0.5
            
            # Create a grid of images
            grid = vutils.make_grid(generated_images, nrow=5, padding=2, normalize=True)
            
            # Display the grid
            st.image(grid.permute(1, 2, 0).numpy(), caption=f"Generated Images for Digit: {selected_digit}")
    else:
        st.info("Select a digit and click 'Generate Images' to start.")